CREATE SCHEMA IF NOT EXISTS public;
CREATE TABLE IF NOT EXISTS public.task
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    assignee_id bigint,
    created_by bigint,
    end_date date,
    estimate character varying(255) COLLATE pg_catalog."default",
    orgId bigint,
    priority character varying(255) COLLATE pg_catalog."default",
    progress integer,
    projectId bigint,
    start_date date,
    status character varying(255) COLLATE pg_catalog."default",
    tags jsonb,
    "timestamp" bigint,
    title character varying(255) COLLATE pg_catalog."default",
    CONSTRAINT task_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.task
    OWNER to postgres;

GRANT ALL ON TABLE public.task TO postgres;

CREATE OR REPLACE FUNCTION notify_change() RETURNS TRIGGER AS $$
DECLARE
action TEXT;
    record JSONB;
BEGIN
    IF TG_OP = 'INSERT' THEN
        action := 'CREATE';
        record := row_to_json(NEW)::jsonb;
        PERFORM pg_notify('data_changes', json_build_object(
            'action', action,
            'type', TG_TABLE_NAME,
            'data', record
        )::text);
RETURN NEW;
ELSIF TG_OP = 'UPDATE' THEN
        action := 'UPDATE';
        record := row_to_json(NEW)::jsonb;
        PERFORM pg_notify('data_changes', json_build_object(
            'action', action,
            'type', TG_TABLE_NAME,
            'data', record
        )::text);
RETURN NEW;
ELSIF TG_OP = 'DELETE' THEN
        action := 'DELETE';
        record := row_to_json(OLD)::jsonb;
        PERFORM pg_notify('data_changes', json_build_object(
            'action', action,
            'type', TG_TABLE_NAME,
            'data', record
        )::text);
RETURN OLD;
END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER data_change_trigger
    AFTER INSERT OR UPDATE OR DELETE ON task
    FOR EACH ROW EXECUTE FUNCTION notify_change();